---
title: "Increase Variation Around Narrow ESD Concepts"
author: NULL
date: NULL
output:
  pdf_document: default
  word_document: default
header-includes:
 - \usepackage[width=\textwidth]{caption}
always_allow_html: yes
csl: ../citations/citations/apa.csl
bibliography: ../citations/citations/citations.bib
link-citations: yes
---

The quantitative benchmarks of ESDs are meant to capture the variation inherent in a state and phase under multiple conditions, from consecutive drought to surpluses of moisture, and following multiple disturbances (CITE). They are intended to capture the variation that would be found in this state and phase combination across the geographic and climatic extents of the ESD in the relevant MLRA. Some of the quantitative benchmarks, of the fractional cover of functional vegetation groups, for Ecological Sites which we collected from ESD's were very narrow. In many of these instances the reported values were more narrow than the uncertainty of the estimates of the true value of the population gleaned from a single AIM plot. It is apparent that several ESD developers did not emphasize the natural variability of the vegetation benchmarks while generating the cover estimates. This may be due to them only collecting quantitative vegetation data at a single site, and not across multiple time points, accordingly it seems in multiple instances they may only have had a point of datum, and did not feel comfortable estimate the variation in the system. 

Well that approach is prudent, it is not prudent for us to assume such narrow ranges of variation. These may unduly penalize estimates of the amount of land under analysis which are meeting condition benchmarks. Here we seek to identify and broaden these estimates, we will use a simple method of *imputing* values in the context of *feature engineering*. A *linear model* will be fit to the benchmark values, which contain realistic ranges, and then the slope of this model will be used to fill in the missing values.  

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = F)
knitr::opts_chunk$set(dpi = 300) 
knitr::opts_chunk$set(message = F)
knitr::opts_chunk$set(warning = F)
```

```{r Install Libraries if required, eval = F}
# install.packages('patchwork')
```

```{r Load Libraries}
library(tidyverse)
```


```{r Import Data and define palette}
ppro <- '../data/processed'
f <- list.files(ppro, pattern = 'csv')

benchmarks <- read.csv(file.path(ppro, f[grep('Quantitative', f)])) %>% 
  filter(ECO.SITE != 'R042BB036NM') %>% 
  mutate(COVER_TYPE = str_to_sentence(COVER_TYPE))

lifeform_pal <- setNames(
  c('#30A934', '#860FAE','#DD4513', '#e7b013'),
  c('Grass', 'Forb', 'Tree', 'Shrub') )

rm(ppro, f)
```

```{r Dummy encode ranges of variation by Functional Group}

bm <- benchmarks %>% 
  mutate(RANGE = UPPER - LOWER, MEAN = (UPPER+LOWER)/2 )  %>% 
  pivot_longer(cols = LOWER:UPPER, names_to = 'ESTIMATE', values_to = 'COVER')  %>% 
  filter(!COVER_TYPE %in% c('Litter', 'Bareground'))

rawplot <- bm %>%  #  something like this should convey the idea of the lower left quad being off... 
  filter(MEAN >= 1) %>% 
  distinct(ECO.SITE, COVER_TYPE, .keep_all = T)  %>% 
  ggplot(aes(x = MEAN, y = RANGE, color = COVER_TYPE)) +
  geom_jitter(width = 0.1) +
  
  geom_segment(aes(x =  0, y = 3, xend = 10, yend = 3), colour = "Black", lty = 2) +
  geom_segment(aes(x = 10, y = 4, xend = 20, yend = 4), colour = "Black", lty = 2) +
  geom_segment(aes(x = 20, y = 5, xend = 30, yend = 5), colour = "Black", lty = 2) +
  geom_segment(aes(x = 30, y = 6, xend = 50, yend = 6), colour = "Black", lty = 2) +

  geom_segment(aes(x = 10, y = 3, xend = 10, yend = 4), colour = "Black", lty = 2) +
  geom_segment(aes(x = 20, y = 4, xend = 20, yend = 5), colour = "Black", lty = 2) +
  geom_segment(aes(x = 30, y = 5, xend = 30, yend = 6), colour = "Black", lty = 2) +
  
  theme_bw() +
  labs(x = NULL, y = "", title = NULL, subtitle = 'Original Data') + 
  xlim(0,50) + ylim(0,35) +
  scale_color_manual('Functional Group', values = lifeform_pal) +
  theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        legend.position = "none",
        plot.margin = unit(c(-0.5, 0.3, 0, 0.3), "cm"),
        plot.subtitle = element_text(hjust = 0.01, vjust = -8))

# rm(benchmarks)
```

```{r Plot Initial variation}

keep_ranges <- bm %>%  # Let us try and filter by group where a member meets these conditions.
  filter(RANGE > 3 & MEAN < 10 | RANGE > 4 & MEAN %in% 10:20 |
           RANGE > 5 & MEAN %in% 20:30 | RANGE > 6 & MEAN %in% 30:50 | RANGE > 7.5 & MEAN > 50) %>%  
  distinct(ECO.SITE, COVER_TYPE, .keep_all = T) %>% 
  select(-ESTIMATE)

predict_data <- bm %>%  
    filter(RANGE <= 3 & MEAN < 10 | RANGE <= 4 & MEAN %in% 10:20 |
           RANGE <= 5 & MEAN %in% 20:30 | RANGE <= 6 & MEAN %in% 30:50 | RANGE <= 7.5 & MEAN > 50) %>%  
  distinct(ECO.SITE, COVER_TYPE, .keep_all = T) %>% 
  select(-ESTIMATE)

# bm %>% 
#  ggplot() +
#  geom_point(aes(x = COVER, y = ECO.SITE, color = ESTIMATE)) +
#  facet_wrap( ~ COVER_TYPE, nrow = 1, scales = 'free_x') +
#  theme_bw() + 
#  theme(plot.title = element_text(hjust = 0.5)) +
#  labs(title = 'Estimates of Ranges of Quantitative Benchmarks',
#       y = NULL, x = NULL)

rm(r3up, r3down, bm)
```


Ranges of estimated benchmark variation were estimated as being too low if they fell within the ranges in Table 1 & Figure 1 *top panel*. These `r nrow( distinct(predict_data, ECO.SITE, COVER_TYPE) )` values were removed from the initial data set. The remaining `r nrow( distinct(keep_ranges, ECO.SITE, COVER_TYPE) )` observations were used as **training** data for the linear model:  $\text{lm(Range} \sim  \text{Mean + Functional Group)}$ (r formula notation). 

   Mean        Range       Percent*
---------    ----------   ----------
 1 -  10         < 3         30.0 %
10 -  20         < 4         26.7 %
20 -  30         < 5         20.0 %
30 -  50         < 6         15.0 %
50 - 100         < 7.5       10.0 %

* This calculated as the *range* divided by the midpoint of the *mean* multipled by 100 to gather a percentile, $\frac{max(Range)} {\text{lower Mean + upper Mean)}} * 100$ 

We believed that the variation associated which each measurement of range would decrease as the mean cover increases. In other words, as the mean of the cover estimate get's larger, the percent variation of the range of them decrease. 

```{r Model the Range of Variation for Estimates of Functional Group Covers}

model <- lm(RANGE ~ MEAN + COVER_TYPE, data = keep_ranges)
anovaTABLE <- anova(model)
colnames(anovaTABLE)[5] <- 'p'

broomSUM <- broom::glance(model)

# par(mfrow=c(2,2))
# plot(model)

prediction <- predict(model, newdata = predict_data, interval = 'prediction', level = 0.8)
prediction <- cbind(predict_data, prediction)

# 2. Regression line + confidence intervals
predplot <- ggplot(prediction, aes(x = MEAN, y = fit, color = COVER_TYPE)) +
  geom_jitter(width = 0.1)  + 
  theme_bw() +
  stat_smooth(method = "lm", show.legend = NULL)+
  geom_ribbon(aes(ymin=lwr, ymax=upr), alpha=0.1) + 
  xlim(0,50) + ylim(0,30) +
  labs(x = NULL, y = 'Range', subtitle  = 'Predictions from Linear Models', title = NULL) +
  scale_color_manual('Functional Group', values = lifeform_pal) +
  
  theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(), 
        legend.position = "none",
        plot.margin = unit(c(-0.5, 0.3, 0, 0.3), "cm"),
        plot.subtitle = element_text(hjust = 0.01, vjust = -8))

rm(predict_data)
```


This simple model served to explain a moderate amount ($r^2$  = `r round(broomSUM$r.squared,2)`) of the variation in the *response variables...*. It found that functional type has a moderate effect on the slope of the trend line (p = `r round(anovaTABLE$p[2], 4)`), and there was slight evidence (p = `r round(anovaTABLE$p[1], 4)`) that increasing the mean of the values had a negative effect on the observed variation. For every one percent increase in the mean of the benchmark values the percent range in variation of the estimates increased by `r round(model$coefficients[['MEAN']], 3)` percent. 

Once the linear model was *fit*, the removed data points had estimates of their values recorded. 

```{r Add predicted ranges to dataset}

# Round prediction to whole number
final_values <- prediction %>% 
  mutate(RANGE = round(fit, 0)) %>% 
  select(ECO.SITE:COVER) %>% 
  bind_rows(., keep_ranges)  %>% 
  group_by(ECO.SITE, COVER_TYPE) %>%  
  slice(rep(1:n(), each = 2))  %>%   
  mutate(
    ESTIMATE = c('LOWER', 'UPPER'),
    COVER = if_else(ESTIMATE == 'LOWER', MEAN - (RANGE/2), MEAN + (RANGE/2)),
    COVER = if_else(MEAN == 0, 0, COVER)) 

finalplot <- final_values %>%  #  something like this should convey the idea of the lower left quad being off... 
  filter(MEAN >= 1) %>% 
  distinct(ECO.SITE, COVER_TYPE, .keep_all = T)  %>% 
  ggplot(aes(x = MEAN, y = RANGE, color = COVER_TYPE)) +
  geom_jitter(width = 0.1)  +
  theme_bw() +
  labs(x = 'Mean Cover', y = "", title = NULL, subtitle  = 'Final Data with Imputed Values') +
  xlim(0,50) + ylim(0,35) +
  scale_color_manual('Functional Group', values = lifeform_pal) +
  scale_x_continuous(breaks = seq(from = 0, to = 50, by = 5 )) + 
  theme(legend.position = "none",
        plot.margin = unit(c(-0.5, 0.3, 0, 0.3), "cm"),
        plot.subtitle = element_text(hjust = 0.01, vjust = -8)) 

legend <- cowplot::get_legend(
     
  ggplot(final_values, aes(x = MEAN, y = RANGE, color = COVER_TYPE)) +
  geom_jitter() +
  scale_color_manual('Functional Group:', values = lifeform_pal) +
  theme(legend.position = "bottom",
        legend.key = element_rect(fill = "white"))
)

rm(lifeform_pal, predict_data, prediction, broomSUM, anovaTABLE, keep_ranges, model)
```


```{r Plot Final Values, fig.cap = 'Imputing the values for '}

patchwork::wrap_plots(rawplot, predplot, finalplot, legend,  ncol=1, 
                      heights=c(1, 1, 1, 0.3)) +
  patchwork::plot_annotation(title = 'Imputed Ranges Around Mean Values')

```

```{r remove the plots}
rm(rawplot, predplot, finalplot, legend)
```

```{r}
bm %>% 
  ggplot() +
  geom_point(aes(x = COVER, y = ECO.SITE, color = ESTIMATE)) +
  facet_wrap( ~ COVER_TYPE, nrow = 1, scales = 'free_x') +
  theme_bw() + 
  theme(plot.title = element_text(hjust = 0.5)) +
  labs(title = 'Estimates of Ranges of Quantitative Benchmarks',
       y = NULL, x = NULL)
```


```{r ensure all input data is here and write out the results to csv}

# remember gotta make the lower and uppers have the new values !!!!!!!!!!!!!!
```


